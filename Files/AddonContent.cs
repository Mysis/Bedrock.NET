using Bedrock.Entities;
using Bedrock.Functions;
using Bedrock.Utility;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Bedrock.Files {
    public class AddonContent {
        private static class Paths {
            public const string Functions = "functions";
            public const string Behaviors = "entities"; //only file that is always generated
            public const string BehaviorPackAnimationTimelines = "animations";
            public const string BehaviorPackAnimationControllers = "animation_controllers";
            public const string ClientEntity = "entity";
            public const string RenderControllers = "render_controllers";
            public const string ResourcePackAnimationControllers = "animation_controllers";
        }
        public const string mcFunctionGenerationMessage = "# Generated by Bedrock.NET";
        public const string jsonGenerationMessage = "// Generated by Bedrock.NET";
        private static StringBuilder StrBuilder = new StringBuilder();
        private static JsonTextWriter JTextWriter = new JsonTextWriter(new StringWriter(StrBuilder)) {
            Formatting = Formatting.Indented,
            Indentation = 1,
            IndentChar = '\t'
        };

        //prefer to use Add() to add entities and functions but you can directly use the fields if you want. Add() is easier though.
        public IDictionary<string, IList<Entity>> Entities { get; private set; } = new Dictionary<string, IList<Entity>>();
        public IDictionary<string, IList<MCFunction>> Functions { get; private set; } = new Dictionary<string, IList<MCFunction>>();
        public IDictionary<string, IList<IEntityTemplate>> EntityTemplates { get; private set; } = new Dictionary<string, IList<IEntityTemplate>>();

        //helper methods for adding content to dicionaries
        //adds uncategorized entities
        public void AddEntities(params Entity[] entities) {
            AddEntities("", entities);
        }
        //adds categorized entities
        public void AddEntities(string category, params Entity[] entities) {
            if (!Entities.ContainsKey(category)) {
                Entities.Add(category, new List<Entity>());
            }
            Entities[category].AddRange(entities);
        }
        //adds uncategorized functions
        public void AddFunctions(params MCFunction[] functions) {
            AddFunctions("", functions);
        }
        //adds categorized functions
        public void AddFunctions(string category, params MCFunction[] functions) {
            if (!Functions.ContainsKey(category)) {
                Functions.Add(category, new List<MCFunction>());
            }
            Functions[category].AddRange(functions);
        }
        //adds uncategorized entity templates
        public void AddEntityTemplates(params IEntityTemplate[] entityTemplates) {
            AddEntityTemplates("", entityTemplates);
        }
        //adds categorized entity templates
        public void AddEntityTemplates(string category, params IEntityTemplate[] functions) {
            if (!EntityTemplates.ContainsKey(category)) {
                EntityTemplates.Add(category, new List<IEntityTemplate>());
            }
            EntityTemplates[category].AddRange(functions);
        }

        public void AddContent(AddonContent content) {
            foreach (string key in content.Entities.Keys) {
                AddEntities(key, content.Entities[key].ToArray());
            }
            foreach (string key in content.Functions.Keys) {
                AddFunctions(key, content.Functions[key].ToArray());
            }
            foreach (string key in content.EntityTemplates.Keys) {
                AddEntityTemplates(key, content.EntityTemplates[key].ToArray());
            }
        }

        //cleanOld will erase all files with the bedrock generation messages
        public void WriteAll(DirectoryInfo behaviorPack, DirectoryInfo resourcePack, bool cleanOld = false) {
            DirectoryInfo functions = behaviorPack.CreateSubdirectory(Paths.Functions);
            DirectoryInfo behaviors = behaviorPack.CreateSubdirectory(Paths.Behaviors);
            DirectoryInfo behaviorPackAnimationTimelines = behaviorPack.CreateSubdirectory(Paths.BehaviorPackAnimationTimelines);
            DirectoryInfo behaviorPackAnimationControllers = behaviorPack.CreateSubdirectory(Paths.BehaviorPackAnimationControllers);
            DirectoryInfo clientEntities = resourcePack.CreateSubdirectory(Paths.ClientEntity);
            DirectoryInfo renderControllers = resourcePack.CreateSubdirectory(Paths.RenderControllers);
            DirectoryInfo resourcePackAnimationControllers = resourcePack.CreateSubdirectory(Paths.ResourcePackAnimationControllers);
            if (cleanOld) {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.Write("Erasing old files... ");
                IList<FileInfo> mcFunctionFiles = new List<FileInfo>();
                mcFunctionFiles.AddRange(RecursiveGetFiles(functions, ".mcfunction"));
                IList<FileInfo> jsonFiles = new List<FileInfo>();
                jsonFiles.AddRange(RecursiveGetFiles(behaviors, ".json"));
                jsonFiles.AddRange(RecursiveGetFiles(behaviorPackAnimationTimelines, ".json"));
                jsonFiles.AddRange(RecursiveGetFiles(behaviorPackAnimationControllers, ".json"));
                jsonFiles.AddRange(RecursiveGetFiles(resourcePack, ".json"));
                foreach (FileInfo mcFunctionFile in mcFunctionFiles) {
                    IEnumerable<string> lines = File.ReadLines(mcFunctionFile.FullName);
                    if (lines.Any() && lines.First() == mcFunctionGenerationMessage) {
                        //Console.WriteLine("deleting " + mcFunctionFile.FullName);
                        mcFunctionFile.Delete();
                    }
                }
                foreach (FileInfo jsonFile in jsonFiles) {
                    IEnumerable<string> lines = File.ReadLines(jsonFile.FullName);
                    if (lines.Any() && lines.First() == jsonGenerationMessage) {
                        //Console.WriteLine("deleting " + jsonFile.FullName);
                        jsonFile.Delete();
                    }
                }
                Console.WriteLine("Done.");
            }

            Console.BackgroundColor = ConsoleColor.White;
            Console.ForegroundColor = ConsoleColor.Black;
            Console.WriteLine("Generating functions... ");
            Console.BackgroundColor = ConsoleColor.Black;
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("Linking full function names to function objects...");
            Console.ForegroundColor = ConsoleColor.DarkGreen;
            foreach (string key in Functions.Keys) {
                foreach (MCFunction mcFunction in Functions[key]) {
                    if (key.Length > 0) {
                        Console.WriteLine("\tLinking " + mcFunction.Name + " to " + key + "...");
                        mcFunction.FunctionName = key + "/" + mcFunction.Name;
                    } else {
                        Console.WriteLine("\tLinking " + mcFunction.Name + " to (base)...");
                        mcFunction.FunctionName = mcFunction.Name;
                    }
                }
            }
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("Writing functions...");
            Console.ForegroundColor = ConsoleColor.Magenta;
            foreach (string key in Functions.Keys) {
                DirectoryInfo directoryToPlaceIn = key.Length == 0 ? functions : functions.CreateSubdirectory(key);
                foreach (MCFunction mcFunction in Functions[key]) {
                    Console.WriteLine("\tWriting " + (key.Length > 0 ? key + "/" : "") + mcFunction.Name + ".mcfunction...");
                    WriteFunction(directoryToPlaceIn.FullName + "/" + mcFunction.Name + ".mcfunction", mcFunction);
                }
            }

            IDictionary<string, IList<Entity>> entitiesToWrite = new Dictionary<string, IList<Entity>>(Entities);
            Console.BackgroundColor = ConsoleColor.White;
            Console.ForegroundColor = ConsoleColor.Black;
            Console.WriteLine("Generating EntityTemplates...");
            foreach (string key in EntityTemplates.Keys) {
                if (!Entities.ContainsKey(key)) {
                    entitiesToWrite.Add(key, new List<Entity>());
                }
                foreach (IEntityTemplate template in EntityTemplates[key]) {
                    entitiesToWrite[key].Add(template.ToEntity());
                }
            }

            foreach (string key in entitiesToWrite.Keys) {
                Console.ForegroundColor = ConsoleColor.White;
                Console.BackgroundColor = ConsoleColor.Black;
                Console.WriteLine("Generating " + (key.Length == 0 ? "uncategorized" : key) + " entities...");
                foreach (Entity entity in entitiesToWrite[key]) {
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine("\tWriting " + entity.Identifier + "...");

                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.WriteLine("\t\tWriting behavior...");
                    DirectoryInfo categoryDirectory = key.Length == 0 ? behaviors : behaviors.CreateSubdirectory(key);
                    WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".behavior.json", entity.GenerateBehavior());

                    Console.ForegroundColor = ConsoleColor.Blue;
                    if (entity.HasBehaviorPackAnimationTimelines) {
                        Console.WriteLine("\t\tWriting behavior pack animation timelines...");
                        categoryDirectory = key.Length == 0 ? behaviorPackAnimationTimelines : behaviorPackAnimationTimelines.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".animations.json", entity.GenerateBehaviorPackAnimationTimelines());
                    }

                    Console.ForegroundColor = ConsoleColor.Cyan;
                    if (entity.HasBehaviorPackAnimationControllers) {
                        Console.WriteLine("\t\tWriting behavior pack animation controllers...");
                        categoryDirectory = key.Length == 0 ? behaviorPackAnimationControllers : behaviorPackAnimationControllers.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".animation_controllers.json", entity.GenerateBehaviorPackAnimationControllers());
                    }

                    Console.ForegroundColor = ConsoleColor.DarkYellow;
                    if (entity.HasClientEntity) {
                        Console.WriteLine("\t\tWriting client entity...");
                        categoryDirectory = key.Length == 0 ? clientEntities : clientEntities.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".entity.json", entity.GenerateClientEntity());
                    }

                    Console.ForegroundColor = ConsoleColor.DarkMagenta;
                    if (entity.HasRenderControllers) {
                        Console.WriteLine("\t\tWriting render controllers...");
                        categoryDirectory = key.Length == 0 ? renderControllers : renderControllers.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".render_controllers.json", entity.GenerateRenderControllers());
                    }

                    Console.ForegroundColor = ConsoleColor.DarkCyan;
                    if (entity.HasResourcePackAnimationControllers) {
                        Console.WriteLine("\t\tWriting resource pack animation controllers...");
                        categoryDirectory = key.Length == 0 ? resourcePackAnimationControllers : resourcePackAnimationControllers.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".animation_controllers.json", entity.GenerateResourcePackAnimationControllers());
                    }
                }
            }
        }

        private static void WriteFunction(string path, MCFunction function) {
            File.WriteAllText(path, mcFunctionGenerationMessage + "\n" + function.ToString());
        }

        private static void WriteJson(string path, JToken jToken) {
            jToken.WriteTo(JTextWriter);
            File.WriteAllText(path, jsonGenerationMessage + "\n" + StrBuilder.ToString());
            StrBuilder.Clear();
        }

        private static void DeleteDirectoryContent(DirectoryInfo directory) {
            foreach (FileInfo f in directory.GetFiles()) {
                f.Delete();
            }
            foreach (DirectoryInfo d in directory.GetDirectories()) {
                d.Delete(true);
            }
        }

        //recursively gets all files with a certain extension. extension must include '.' (ie ".json").
        private static IList<FileInfo> RecursiveGetFiles(DirectoryInfo directory, string extension) {
            return RecursiveGetFiles(directory, extension, new List<FileInfo>());
        }

        private static IList<FileInfo> RecursiveGetFiles(DirectoryInfo directory, string extension, IList<FileInfo> filesWithExtension) {
            foreach (FileInfo file in directory.GetFiles()) {
                if (file.Extension == extension) {
                    filesWithExtension.Add(file);
                }
            }
            foreach (DirectoryInfo dir in directory.GetDirectories()) {
                RecursiveGetFiles(dir, extension, filesWithExtension);
            }
            return filesWithExtension;
        }
    }
}
