using Bedrock.Entities;
using Bedrock.Functions;
using Bedrock.Utility;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Bedrock.Files {
    public class AddonContent {
        private static class Paths {
            public const string Functions = "functions";
            public const string Behaviors = "entities"; //only file that is always generated
            public const string BehaviorPackAnimationTimelines = "animations";
            public const string BehaviorPackAnimationControllers = "animation_controllers";
            public const string ClientEntity = "entity";
            public const string RenderControllers = "render_controllers";
            public const string ResourcePackAnimationControllers = "animation_controllers";
        }
        public const string mcFunctionGenerationMessage = "# Generated by Bedrock.NET";
        public const string jsonGenerationMessage = "// Generated by Bedrock.NET";
        private static StringBuilder StrBuilder = new StringBuilder();
        private static JsonTextWriter JTextWriter = new JsonTextWriter(new StringWriter(StrBuilder)) {
            Formatting = Formatting.Indented,
            Indentation = 1,
            IndentChar = '\t'
        };

        public IDictionary<string, IList<Entity>> Entities { get; private set; } = new Dictionary<string, IList<Entity>>(); //category, list of entities in that category
        public IDictionary<string, IList<MCFunction>> Functions { get; private set; } = new Dictionary<string, IList<MCFunction>>();

        //adds uncategorized entities
        public void Add(params Entity[] entities) {
            Add("", entities);
        }
        public void Add(string category, params Entity[] entities) {
            if (!Entities.ContainsKey(category)) {
                Entities.Add(category, new List<Entity>());
            }
            Entities[category].AddRange(entities);
        }

        //adds uncategorized functions
        public void Add(params MCFunction[] functions) {
            Add("", functions);
        }
        public void Add(string category, params MCFunction[] functions) {
            if (!Functions.ContainsKey(category)) {
                Functions.Add(category, new List<MCFunction>());
            }
            Functions[category].AddRange(functions);
        }

        public void AddContent(AddonContent content) {
            foreach (string key in content.Entities.Keys) {
                if (!Entities.ContainsKey(key)) {
                    Entities.Add(key, new List<Entity>());
                }
                Entities[key].AddRange(content.Entities[key]);
            }
            Functions.AddRange(content.Functions);
        }

        //eraseOld will erase all files in the behavior pack animations directory, behavior pack animation controllers directory, behavior pack behaviors directory, behavior pack functions directory, resource pack entities directory, and resource pack render controllers directory
        public void WriteAll(DirectoryInfo behaviorPack, DirectoryInfo resourcePack, bool eraseOld = false) {
            DirectoryInfo functions = behaviorPack.CreateSubdirectory(Paths.Functions);
            DirectoryInfo behaviors = behaviorPack.CreateSubdirectory(Paths.Behaviors);
            DirectoryInfo behaviorPackAnimationTimelines = behaviorPack.CreateSubdirectory(Paths.BehaviorPackAnimationTimelines);
            DirectoryInfo behaviorPackAnimationControllers = behaviorPack.CreateSubdirectory(Paths.BehaviorPackAnimationControllers);
            DirectoryInfo clientEntities = resourcePack.CreateSubdirectory(Paths.ClientEntity);
            DirectoryInfo renderControllers = resourcePack.CreateSubdirectory(Paths.RenderControllers);
            DirectoryInfo resourcePackAnimationControllers = resourcePack.CreateSubdirectory(Paths.ResourcePackAnimationControllers);
            if (eraseOld) {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.Write("Erasing old files... ");
                IList<FileInfo> mcFunctionFiles = new List<FileInfo>();
                mcFunctionFiles.AddRange(RecursiveGetFiles(functions, ".mcfunction"));
                IList<FileInfo> jsonFiles = new List<FileInfo>();
                jsonFiles.AddRange(RecursiveGetFiles(behaviors, ".json"));
                jsonFiles.AddRange(RecursiveGetFiles(behaviorPackAnimationTimelines, ".json"));
                jsonFiles.AddRange(RecursiveGetFiles(behaviorPackAnimationControllers, ".json"));
                jsonFiles.AddRange(RecursiveGetFiles(resourcePack, ".json"));
                foreach (FileInfo mcFunctionFile in mcFunctionFiles) {
                    IEnumerable<string> lines = File.ReadLines(mcFunctionFile.FullName);
                    if (lines.Any() && lines.First() == mcFunctionGenerationMessage) {
                        //Console.WriteLine("deleting " + mcFunctionFile.FullName);
                        mcFunctionFile.Delete();
                    }
                }
                foreach (FileInfo jsonFile in jsonFiles) {
                    IEnumerable<string> lines = File.ReadLines(jsonFile.FullName);
                    if (lines.Any() && lines.First() == jsonGenerationMessage) {
                        //Console.WriteLine("deleting " + jsonFile.FullName);
                        jsonFile.Delete();
                    }
                }
                Console.WriteLine("Done.");
            }

            Console.BackgroundColor = ConsoleColor.White;
            Console.ForegroundColor = ConsoleColor.Black;
            Console.WriteLine("Generating functions... ");
            Console.BackgroundColor = ConsoleColor.Black;
            Console.ForegroundColor = ConsoleColor.DarkGreen;
            Console.WriteLine("Linking full function names to function objects...");
            foreach (string key in Functions.Keys) {
                foreach (MCFunction mcFunction in Functions[key]) {
                    mcFunction.FunctionName = key + "/" + mcFunction.Name;
                }
            }
            Console.ForegroundColor = ConsoleColor.Magenta;
            foreach (string key in Functions.Keys) {
                DirectoryInfo directoryToPlaceIn = key.Length == 0 ? functions : functions.CreateSubdirectory(key);
                foreach (MCFunction mcFunction in Functions[key]) {
                    Console.WriteLine("\tWriting " + key + "/" + mcFunction.Name + ".mcfunction...");
                    File.WriteAllText(directoryToPlaceIn.FullName + "/" + mcFunction.Name + ".mcfunction", mcFunctionGenerationMessage + "\n" + mcFunction.ToString());
                }
            }

            foreach (string key in Entities.Keys) {
                Console.BackgroundColor = ConsoleColor.White;
                Console.ForegroundColor = ConsoleColor.Black;
                Console.WriteLine("Generating " + (key.Length == 0 ? "uncategorized" : key) + " entities...");
                Console.BackgroundColor = ConsoleColor.Black;
                foreach (Entity entity in Entities[key]) {
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine("Writing " + entity.Identifier + "...");

                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.WriteLine("\tWriting behavior...");
                    DirectoryInfo categoryDirectory = key.Length == 0 ? behaviors : behaviors.CreateSubdirectory(key);
                    WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".behavior.json", entity.GenerateBehavior());

                    Console.ForegroundColor = ConsoleColor.Blue;
                    if (entity.HasBehaviorPackAnimationTimelines) {
                        Console.WriteLine("\tWriting behavior pack animation timelines...");
                        categoryDirectory = key.Length == 0 ? behaviorPackAnimationTimelines : behaviorPackAnimationTimelines.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".animations.json", entity.GenerateBehaviorPackAnimationTimelines());
                    }

                    Console.ForegroundColor = ConsoleColor.Cyan;
                    if (entity.HasBehaviorPackAnimationControllers) {
                        Console.WriteLine("\tWriting behavior pack animation controllers...");
                        categoryDirectory = key.Length == 0 ? behaviorPackAnimationControllers : behaviorPackAnimationControllers.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".animation_controllers.json", entity.GenerateBehaviorPackAnimationControllers());
                    }

                    Console.ForegroundColor = ConsoleColor.DarkYellow;
                    if (entity.HasClientEntity) {
                        Console.WriteLine("\tWriting client entity...");
                        categoryDirectory = key.Length == 0 ? clientEntities : clientEntities.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".entity.json", entity.GenerateClientEntity());
                    }

                    Console.ForegroundColor = ConsoleColor.DarkMagenta;
                    if (entity.HasRenderControllers) {
                        Console.WriteLine("\tWriting render controllers...");
                        categoryDirectory = key.Length == 0 ? renderControllers : renderControllers.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".render_controllers.json", entity.GenerateRenderControllers());
                    }

                    Console.ForegroundColor = ConsoleColor.DarkCyan;
                    if (entity.HasBehaviorPackAnimationControllers) {
                        Console.WriteLine("\tWriting resource pack animation controllers...");
                        categoryDirectory = key.Length == 0 ? resourcePackAnimationControllers : resourcePackAnimationControllers.CreateSubdirectory(key);
                        WriteJson(categoryDirectory.FullName + "/" + entity.Identifier + ".animation_controllers.json", entity.GenerateResourcePackAnimationControllers());
                    }
                }
            }
        }

        private static void WriteJson(string path, JToken jToken) {
            jToken.WriteTo(JTextWriter);
            File.WriteAllText(path, jsonGenerationMessage + "\n" + StrBuilder.ToString());
            StrBuilder.Clear();
        }

        private static void DeleteDirectoryContent(DirectoryInfo directory) {
            foreach (FileInfo f in directory.GetFiles()) {
                f.Delete();
            }
            foreach (DirectoryInfo d in directory.GetDirectories()) {
                d.Delete(true);
            }
        }

        //recursively gets all files with a certain extension. extension must include '.' (ie ".json").
        private static IList<FileInfo> RecursiveGetFiles(DirectoryInfo directory, string extension) {
            return RecursiveGetFiles(directory, extension, new List<FileInfo>());
        }

        private static IList<FileInfo> RecursiveGetFiles(DirectoryInfo directory, string extension, IList<FileInfo> filesWithExtension) {
            foreach (FileInfo file in directory.GetFiles()) {
                if (file.Extension == extension) {
                    filesWithExtension.Add(file);
                }
            }
            foreach (DirectoryInfo dir in directory.GetDirectories()) {
                RecursiveGetFiles(dir, extension, filesWithExtension);
            }
            return filesWithExtension;
        }
    }
}
